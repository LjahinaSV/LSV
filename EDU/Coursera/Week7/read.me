Set Hesh-functions Dictionry
Множества. Хэш-функции. Словари
Полезные методы строк

Множества и хеш-функции
В языке Питон множества имеют тот же смысл, что и в математике: набор объектов без определенного порядка. В множество можно добавлять и удалять объекты, проверять принадлежность объекта множества и перебирать все объекты множества. 

Также над множествами можно совершать групповые операции, например, пересекать и объединять два множества.

Проверка принадлежности элемента множеству, а также операции удаления и добавления элементов, осуществляются за O(1) (если бы мы хранили элементы в списке и хотели бы проверить принадлежность элемента списку, то нам потребовалось бы O(N) операций, где N - длина списка).

Такая скорость достигается использованием хеш-таблиц. Хеш-таблица - это массив достаточно большого размера (назовем этот размер K). Каждому неизменяемому объекту можно сопоставить по некоторому правилу число M от 0 до K и поместить этот объект в ячейку списка с индексом M. Например, для целых чисел таким правилом сопоставления может быть просто подсчет остатка от деления целого числа на K. Операцию взятия остатка будет нашей хеш-функцией.

Теперь если нам нужно проверить, принадлежит ли некоторое число множеству, мы просто считаем хеш-функцию от него и проверяем, лежит ли в ячейке с индексом, равным результату вычисления хеш-функции наш объект или нет. Для других типов данных можно применить такой подход: любой объект так или иначе является последовательностью байт. Будем интерпретировать эту последовательность байт как число и подсчитаем хеш-функцию для этого числа. 

Естественно, может оказаться, что несколько объектов дают один и тот же хеш (отображение между огромным множеством различных объектов и скромным размером множества допустимых хешей не может быть биективным). Такие проблемы можно разрешить, не ухудшая асимптотическую сложность. Подробнее такие методы вы будете изучать на курсе алгоритмов.

Поскольку, например, числа, могут быть достаточно длинными, то операция подсчета хеш-функции при каждой операции с этим объектов в множестве может быть очень медленной. Поэтому каждый неизменяемый объект в Питоне имеет заранее насчитанный хеш, который подсчитывается один раз при его создании. Кстати, с помощью этих же хешей можно понимать, есть ли уже объект в памяти и не создавать новых объектов, а просто подвешивать еще одну ссылку на уже существующий объект.

Изменяемые типы, такие как список, не имеют заранее насчитанных хешей. Изменение всего одного элемента в списке привело бы к полному пересчету хеша для всего списка, что катастрофически замедлило бы работу со списками. Поэтому у изменяемых объектов нет хеша и они не могут быть добавлены в множество.

Само множество также является изменяемым объектом и не может быть, например, элементом другого множества.

Существуют также неизменяемые множества, которые создаются с помощью функции frozenset.


Создание множеств
Множество в теле программы может быть создано с помощью записи элементов через запятую в фигурных скобках: 

mySet = {3, 1, 2}
print(mySet)

Вывод с помощью print осуществляется в том же формате. Порядок элементов в множестве может быть случайным, т.к. хеш функция не гарантирует, что если A>B, то h(A) > h(B).

Если при задании множества присутствовало несколько одинаковых элементов, то они попадут в множество в единственном экземпляре:

firstSet = {1, 2, 1, 3}
secondSet = {3, 2, 1}
print(firstSet == secondSet)

Эта программы выведет True (множества можно сравнивать на равенство).

Также множества можно создавать с помощью функции set, которая может принимать в качестве параметра что угодно итерируемое:

setFromList = set([1, 2, 3])
print(setFromList)
setFromTuple = set((4, 5, 6))
print(setFromTuple)
setFromStr = set("lol")
print(setFromStr)
setFromRange = set(range(2, 22, 3))
print(setFromRange)
setFromMap = set(map(abs, (1, 2, 3, -2, -4)))
print(setFromMap)
setFromSet = set({1, 2, 3})
print(setFromSet)

Вывод этой программы такой:

{1, 2, 3}

{4, 5, 6} 

{'l', 'o'} 

{2, 5, 8, 11, 14, 17, 20} 

{1, 2, 3, 4} 

{1, 2, 3} 

Множество также является итерируемым объектом (еще раз: объекты идут в "случайном" порядке, не по возрастанию!).

Множество может содержать в себе объекты разных типов: 

mixedSet = {1, 3.14, (1, 2, 3), "i have no idea why i'm here"}
print(mixedSet)

По аналогии со строками, списками и кортежами, количество элементов в множестве можно узнать с помощью функции len.

Из множества можно сделать список или кортеж с помощью функций list и tuple соответственно. Применение функции str к множеству даст нам текстовое представление (элементы в фигурных скобках, разделенные запятыми). 

Частой операцией является вывод упорядоченных элементов множества. Это можно сделать, применив функцию sorted сразу к множеству (ведь оно итерируемо):

mySet = {'abba', 'a', 'long string'}
print(', '.join(mySet))
print(', '.join(sorted(mySet)))

Вывод этой программы будет:

long string, a, abba

a, abba, long string 

К множеству можно применять функцию map.


Работа с множествами. Работа с элементами множеств

Чтобы создать пустое множество нужно написать: 

emptySet = set()

Писать пустые фигурные скобки нельзя (во второй части лекции узнаете почему).

Добавление элемента в множество осуществляется с помощью метода add, если элемент уже был в множестве, то оно не изменится.

Перебрать элементы множества можно с помощью for (for умеет ходить по любым итерируемым объектам):

mySet = {1, '2', 2, '1'}
for elem in mySet:
    print(elem, end=' ')
Вывод такой программы будет ''1 1 2 2'', но упорядоченность является чистой случайностью.

Чтобы проверить, входит ли элемент X в множество A достаточно написать X in A. Результатом этой операции будет True или False. Чтобы проверить, что элемент не лежит в множестве можно писать not X in A, или, более по-человечески X not in A.

mySet = {1, 2, 3}
if 1 in mySet:
    print('1 in set')
else:
    print('1 not in set')
x = 42
if x not in mySet:
    print('x not in set')
else:
    print('x in set')

Вывод этой программы будет:

1 in set
x not in set 

Чтобы удалить элемент из множества, можно воспользоваться одним из двух методов: discard или remove. Если удаляемого элемента в множестве не было, то discard не изменит состояния множества, а remove выпадет с ошибкой.

Групповые операции над множествами
В Питоне можно работать не только с отдельными элементами множеств, но и с множествами в целом. Например, для множеств определены следующие операции:


Операция    Описание

A | B       Объединение множеств
A & B       Пересечение множеств
A - B       Множество, элементы которого входят в A, но не входят в B
A ^ B       Элементы входят в A | B, но не входят в A & B

В результате этих операций создается новое множество, однако для них определена и сокращенная запись: |=, &=, -= и ^=. Такие операции изменяют множество, находящееся слева от знака операции.

Для множеств также определены операции сравнения:

Операция    Описание

A == B      Все элементы совпадают
A != B      Есть различные элементы
A <= B      Все элементы A входят в B
A < B       A <= B и A != B

Также определены операции > и >=. Все групповые операции и сравнения проводятся над множествами за время, пропорциональное количеству элементов в множествах.


Словари
В жизни нередко возникает необходимость сопоставить ключу значение. Например, в англо-русском словаре английскому слову сопоставляется одно или несколько русских слов. Здесь английское слово является ключом, а русское - значением. 

В языке Питон есть структура данных словарь, которая позволяет реализовывать подобные операции. При этом объекты-ключи уникальны и каждому из них сопоставлен некоторый объект-значение. Ограничения на ключи такие же, как на элементы множества, а вот значения могут быть и изменяемыми.

По-сути, словарь является множеством, где каждому элементу-ключу сопоставлен еще и объект-значение.

Создать словарь в исходном тексте программы можно записав в фигурных скобках пары ключ-значения через запятую, а внутри пары ключ отделяется от значения двоеточием:

countries = {'Russia' : 'Europe', 'Germany' : 'Europe', 'Australia' : 'Australia'}

Добавлять пары ключ значение в словарь очень просто: это делается по аналогии со списками: 

sqrs = {}
sqrs[1] = 1
sqrs[2] = 4
sqrs[10] = 100
print(sqrs)

Пустой словарь можно создать, написав пустые фигурные скобки (это будет словарь, а не множество).

Словарь также можно конструировать из других объектов с помощью функции dict:

myDict = dict([['key1', 'value1'], ('key2', 'value2')])
print(myDict)

На вход функции должен подавать iterable, каждый элемент которого, в свою очередь, является iterable строго с двумя элементами - ключом и значением.

Узнавать значение по ключу можно также с помощью записи ключа после имени словаря в квадратных скобках:

phones = {'police' : 102, 'ambulance' : 103, 'firefighters' : 101}
print(phones['police'])

Если такого ключа в словаре нет, то возникнет ошибка.

Удаление элемента из словаря делается специальной командой del. Это не функция, после слова del ставится пробел, затем пишется имя словаря, а затем, в квадратных скобках, удаляемый ключ:

phones = {'police' : 102, 'ambulance' : 103, 'firefighters' : 101}
del phones['police']
print(phones)

Проверка принадлежности ключа словарю осуществляется с помощью операции key in dictionary (точно также, как проверка принадлежности элемента множеству).

Словарь является iterable и возвращает ключи в случайном порядке. Например, такой код напечатает содержимое словаря:

phones = {'police' : 102, 'ambulance' : 103, 'firefighters' : 101}
for service in phones:
    print(service, phones[service])

Также существует метод items, который возвращает iterable, содержащий в себе кортежи ключ-значение для всевозможных ключей.

phones = {'police' : 102, 'ambulance' : 103, 'firefighters' : 101}
for service, phone in phones.items():
    print(service, phone)


Когда нужно использовать словари
По прямому назначению: сопоставление ключа значению (названия дней недели, переводы слов и т. д.). 

Для подсчета числа объектов. При очередной встрече объекта счетчик увеличивается на единицу. Это похоже на сортировку подсчётом. 

Для хранения разреженных массивов. Например, если мы хотим хранить цену 92, 95 и 98 бензина, то могли бы создать массив из 99 элементов и хранить в нём. Но большая часть элементов не нужны - массив разреженный. Словарь здесь подходит больше. 

Для подсчета числа элементов удобно использовать метод get. Он принимает два параметра: ключ для которого нужно вернуть значения и значение, которое будет возвращено, если такого ключа нет. Например, подсчитать сколько раз входит в последовательность каждое из чисел можно с помощью такого кода:

seq = map(int, input().split())
countDict = {}
for elem in seq:
    countDict[elem] = countDict.get(elem, 0) + 1
for key in sorted(countDict):
    print(key, countDict[key], sep=' : ')
    
    
Полезные методы строк
It's dangerous to go alone! Take this:

isalpha - проверяет, что все символы строки являются буквами.

isdigit - проверяет, что все символы строки являются цифрами.

isalnum - проверяет, что все символы строки являются буквами или цифрами.

islower - проверяет, что все символы строки являются маленькими (строчными) буквами.

isupper - проверяет, что все символы строки являются большими (заглавными, прописными) буквами.

lstrip - обрезает все пробельные символы в начале строки.

rstrip - обрезает все пробельные символы в конце строки.

strip - обрезает все пробельные символы в начале и конце строки.


Пример решения сложной задачи на словари
Рассмотрим такую задачу: словарь задан в виде набора строк, в каждой строке записано слово на английском языке, затем следует символ -, затем, через запятую, перечислены возможные переводы слова на латынь. 

Требуется составить латино-английский словарь и вывести его в том же виде. Все слова должны быть упорядочены по алфавиту. Возможные переводы одного слова должны быть также упорядочены по алфавиту.

Например, для ввода:

3
apple - malum, pomum, popula
fruit - baca, bacca, popum
punishment - malum, multa

Вывод должен выглядеть так:

7
baca - fruit
bacca - fruit
malum - apple, punishment
multa - punishment
pomum - apple
popula - apple
popum - fruit

Идея решения заключается в следующем: разрежем каждую строку на английское и латинские слова. Каждое из латинских слов возьмем в качестве ключа и добавим к его значениям английское слово (переводов может быть несколько). Затем пройдем по сортированным ключам и для каждого ключа выведем отсортированный список переводов:

n = int(input())
latinEnglish = {}
for i in range(n):
    line = input()
    english = line[:line.find('-')].strip()
    latinsStr = line[line.find('-') + 1:].strip()
    latins = map(lambda s : s.strip(), latinsStr.split(','))
    for latin in latins:
        if latin not in latinEnglish:
            latinEnglish[latin] = []
        latinEnglish[latin].append(english)
print(len(latinEnglish))
for latin in sorted(latinEnglish):
    print(latin, '-', ', '.join(sorted(latinEnglish[latin])))
    
