Tuple For List
Кортежи. Цикл for. Списки

Кортежи
По аналогии со строками, которые могут хранить в себе отдельные символы, в языке Питон существуют тип кортеж, который позволяет хранить в себе произвольные элементы. 

Кортеж может состоять из элементов произвольных типов и является неизменяемым типом, т.е. нельзя менять отдельные элементы кортежа, как и символы строки. Константные кортежи можно создавать в программе, записывая элементы через запятую и окружая скобками. Например, testTuple = (1, 2, 3). В случае, если кортеж является единственным выражением слева или справа от знака присваивания, то скобки могут быть опущены. Во всех остальных случаях скобки опускать не следует - это может привести к ошибкам.

Многие приемы и функции для работы со строками также подходят и для кортежей, например, можно складывать два кортежа:

a = (1, 2, 3)
b = (4, 5, 6)
print(a + b)

В результате применения этой операции будет выведено (1, 2, 3, 4, 5, 6). В случае сложения создается новый кортеж, который содержит в себе элементы сначала из первого, а затем второго кортежа (точно так же как и в случае со строками). Также кортеж можно умножить на число, результат этой операции аналогичен умножению строки на число.

Приведем пример, когда опускание скобок приводит к ошибке. (1, 2) + (3, 4) будет давать (1, 2, 3, 4), а 1, 2 + 3, 4 будет давать (1, 5, 4), т. к. сумма будет понята Питоном как выражение для второго элемента кортежа.

Кортеж можно получить из строки, вызвав функцию tuple от строки. В результате каждая буква станет элементом кортежа. К кортежу можно применять функцию str, которая вернет текстовое представление кортежа (элементы, перечисленные через запятую с пробелом и разделенные пробелами). 

К кортежу можно применять функцию len и обращаться к элементам по индексу (в том числе по отрицательному) также как и к строкам.

В одном кортеже могут храниться элементы различных типов, например, строки, числа и другие кортежи вперемешку. Например, в кортеже myTuple = (('a', 1, 3.14), 'abc', ((1), (2, ))), myTuple[0] будет кортежем ('a', 1, 3.14), myTuple[1] строкой 'abc', а myTuple[2] кортежем состоящим из числа 1 и кортежа из одного элемента (2, ). Числа, записанные в скобках, интерпретируются как числа, в случае возникновения необходимости создать кортеж из одного элемента необходимо после значения элемента написать запятую. Если вывести myTuple[2][1], то напечатается (2,), а если вывести myTuple[2][1][0], то будет напечатано число 2.

Кортеж, содержащий в себе один элемент, называется синглтоном. Как и к строкам, к кортежам можно применять операцию среза с тем же смыслом параметров. Если в срезе один параметр, то будет возвращена ссылка на элемент с соответствующим номером. Например, print((1, 2, 3)[2]) напечатает 3. Если же в срезе более одного параметра, то будет сконструирован кортеж, даже если он будет синглтоном. Например, в случае вызова print((1, 2, 3)[1:]) будет напечатано (2, 3), а в случае вызова print((1, 2, 3)[2:]) будет напечатан синглтон (3,).

Кортежи, обычно, предназначаются для хранения разнотиповых значений, доступ к которым может быть получен в результате обращения по индексу или с помощью операции распаковки.

Распаковкой называется процесс присваивания, в котором кортеж, составленный из отдельных переменных находится в левой части выражения. В таком выражении справа должен находится кортеж той же длины. Например, в результате выполнения такого кода:

manDesc = ("Ivan", "Ivanov", 28)
name, surname, age = manDesc

В переменной name кажется ''Ivan'', в surname - ''Ivanov'', а в переменной age число 28. На английском распаковка кортежа называется tuple unpacking.


Функция range, цикл for
Процесс создания кортежа называется упаковкой кортежа. Если в одном выражении присваивания происходит и упаковка и распаковка кортежа, то сначала выполняется упаковка, а затем распаковка кортежа. Так, в результате работы программы:

a, b, c = 1, 2, 3
a, b, c = c, b, a
print(a, b, c)

будет выведено 3 2 1. Обратите внимание, что функции print передается в качестве параметра не кортеж, а три целых числа.

Главное что нужно понять, что записать вида (a, b, c) = (c, b, a) не эквивалентна цепочке присваиваний вида a = c; b = b; c = a. Такая цепочка присваиваний привела бы к тому, что в переменных a, b, c оказались бы значения 3, 2, 3.

Функция range
В языке Питон есть функция range, которая позволяет генерировать объекты типа iterable (к элементам которых можно получать последовательный доступ), состоящие из целых чисел.

Для вывода объектов типа iterable мы будем пользоваться функцией tuple, которая позволяет сделать кортеж, состоящий из всех элементов iterable, записанных последовательно.

Например, если запустить программу

print(tuple(range(10)))

то будет напечатано (0, 1, 2, 3, 4, 5, 6, 7, 8, 9). Функция range с одним параметром n генерирует iterable, содержащий последовательные числа от 0 до n-1.

Существует вариант range с двумя параметрами, range(from, to) сгенерирует iterable со всеми числами от from до to-1 включительно.

Также существует range с тремя параметрами range(from, to, step), который сгенерирует iterable с числами от from, не превышающие to с шагом изменения step. Если шаг отрицателен, то from должен быть больше to. Например, range(10, 0, -2) сгенерирует последовательность чисел 10, 8, 6, 4, 2. 0 не будет входить в эту последовательность.

Во многом параметры range напоминают значения параметров в срезах строк.

Цикл for
Цикл for позволяет поочередно перебрать элементы из чего-нибудь итерируемого (iterable или tuple). Например, мы можем перебрать названия цветов яблок таким способом:

for color in ('red', 'green', 'yellow'):
    print(color, 'apple')

В результате выполнения этой программы будет напечатано:

red apple
green apple
yellow apple

На место переменной color будут поочередно подставляться значения из кортежа. В общем случае цикл for выглядит так for имяПеременной in нечтоИтерируемое:

Все действия, которые должны выполняться в for, должны выделяться отступом, как и в if или while. Работа цикла for может быть прервана с помощью команды break или может быть осуществлен переход к следующей итерации с помощью continue. Эти команды имеют тот же эффект, что и при работе с циклом while.

Часто for используется вместе с функцией range. Например, с помощью for можно напечатать нечетные числа от 1 до 100:

for i in range(1, 100, 2):
    print(i)

Внутри for может быть расположен и другой for. Вот так выглядит код для вывода таблицы умножения всех чисел от 1 до 10 (не очень красивой):

for i in range(1, 11):
    for j in range(1, 11):
        print(i * j, end=' ')
    print()

Как вы можете заметить, при использовании функции range в for мы не преобразовывали iterable в tuple. Это связано с тем, что for как раз хочет получать последовательный доступ, который умеет давать iterable. Tuple умеет намного больше, но здесь его использование приведет к ненужным затратам времени и памяти.


Списки
Список в Питоне является аналогом массивов в других языках программирования. Список - это набор ссылок на объекты (также как и кортеж), однако он является изменяемым. 

Константные списки записываются в квадратных скобках, все остальное в них аналогично кортежам. Например, можно создать список с числами от 1 до 5: myList = [1, 2, 3, 4, 5].

Списки и кортежи легко преобразуются друг в друга. Для преобразования списка в кортеж надо использовать уже известную нам функцию tuple, а для преобразования кортежа в список нужна функция list. Также функцию list можно применить к строке. В результате этого получится список, каждым элементом которого будет буква из строки. Так list('abc') будет выглядеть как ['a', 'b', 'c'].

К спискам также применима функция len и срезы, которые работают также как в кортежах.

Главным отличием списка от кортежа является изменяемость. То есть можно взять определенный элемент списка и изменить его (он может быть в левой части операции присваивания).

Например, в результате выполнения такого кода:

myList = [1, 2, 3]
myList[1] = 4
print(myList)

будет напечатано [1, 4, 3].

Изменение символа (или элемента в кортеже) можно было реализовать, сделав два среза и конкатенация первой части строки, нового символа и "хвоста" строки. Это очень медленная операция, время ее выполнения пропорционально длине строки. Замена элемента в списке осуществляется за O(1), т. е. не зависит от длины списка.

Изменение списков
Список, как и другие типы в языке Питон, является ссылкой на список ссылок. При этом список является изменяемым объектом, т. е. содержимое по этой ссылке может поменяться. Рассмотрим такой пример:

a = [1, 2]
b = a
b[0] = 3
print(a)

В результате выполнения этой программы будет напечатано [3, 2]. Это связано с тем, что присваивание в Питоне - это просто "привязывание" нового "ярлычка" к объекту. После присваивания b = a обе ссылки начинают показывать на один и тот же объект и если он изменен по одной ссылке, то по второй ссылке он также будет доступен в измененном состоянии.

Если же написать такой код: 

a = [1, 2]
b = [1, 2]
a[0] = 3
print(b)

то будет выведено [1, 2]. Несмотря на то, что объекты имеют одинаковое значение из-за их мутабельности (изменяемости) для каждого значения будет создан отдельный объект и ссылки a и b будут показывать на разные объекты. Изменение одного из них, естественно, не приводит к изменению другого.

В результате выполнения такого кода:

a = [1, 2]
b = a
a = [3, 4]
print(b)

будет выведено [1, 2]. Сначала в памяти создается объект [1, 2] и к нему привязывается ссылка a, затем к тому же объекту привязывается ссылка b, а затем создается новый объект [3, 4], к которому привязывается ссылка a (отвязавшись от своего предыдущего значения). При этом ссылка b не изменилась (она может измениться только если b будет участвовать в левой части присваивания) и по-прежнему показывает на [1, 2].

Если списки переданы в функцию в качестве параметров, то их содержимое также может быть изменено этой функцией:

def replaceFirst(myList):
    myList[0] = 'x'
    
nowList = list('abcdef')
replaceFirst(nowList)
print(nowList)

Выводе этой программы будет ['x', 'b', 'c', 'd', 'e', 'f'].

Однако, сама ссылка внутри функции не может быть изменена, если она передана как параметр функции. Рассмотрим пример:

def reverseList(funcList):
    funcList = funcList[::-1]
    
mainList = list('abc')
reverseList(mainList)
print(mainList)

Эта программа не развернет список, т. е. вывод будет ['a', 'b', 'c'].

Здесь в основной программе конструируется объект ['a', 'b', 'c'] и к нему привязывается ссылка mainList. При передаче mainList в качестве параметра в функцию создастся еще одна ссылка funcList, показывающая на объект ['a', 'b', 'c']. В результате применения среза создастся новый объект ['c', 'b', 'a'] и ссылка funcList начнет указывать на него. Однако, значение ссылки mainList при этом не изменится и со значениями по ссылке mainList также ничего не произойдет (напомним, что операция среза создает новый объект, не изменяя старый).


Методы split и join
Строки имеют два полезных метода, которые пригодятся при работе со списками. 

Метод split позволяет разрезать строку (string) на отдельные слова ("токены"). В качестве разделителя может выступать пробел, символ табуляции или перевода строки. Этот метод не изменяет строку и возвращает список строк-токенов.

Например, если запустить такую программу

print('red green        blue'.split())

то будет напечатано ['red', 'green', 'blue']. Количество разделителей между токенами не играет роли.

Чтобы научиться читать числа из одной строки нужно научиться еще одной функции - map. Функция map принимает два параметра: первый это функции, а второй - iterable элементов, к которому нужно применить эту функцию. В результате получается iterable с результатом применения функции к каждому элементу списка параметра.

Например, такой код:

print(list(map(len, ['red', 'green', 'blue'])))

напечатает [3, 5, 4] - список с результатом применения функции len к списку ['red', 'green', 'blue'].

Метод split в сочетании с функцией map удобно использовать для считывания списка чисел, записанных в одну строку и разделенных пробелами. Такое считывание будет выглядеть так:

numList = list(map(int, input().split()))

Сначала осуществляется считывание строки, затем выполняется метод split, который создает список токенов, состоящих из цифр, а затем к каждому токену применяется функция int. В результате этого получается список цифр.

Метод join позволяет объединить iterable строк, используя ту строку, к которой он применен, в качестве разделителя. Например, такой код:

print(', '.join(['Veni', 'Vidi', 'Vici']))

выведет Veni, Vidi, Vici. Строка ', ' будет выступать в качестве разделителя который будет вставляться после каждой строки из списка-параметра (кроме последней).

Метод join позволяет быстро и коротко выводить списки чисел. Проблема в том, что он умеет принимать в качестве параметра только iterable строк. Но с помощью функции map мы можем легко получить iterable из списка чисел, применив к каждому элементу функцию str. Вывод списка чисел numList разделенных пробелами будет выглядеть так:

numList = [1, 2, 3]
print(' '.join(map(str, numList)))


Полезные методы работы со списками
К переменным типа список можно применять методы, перечислим некоторые из них: 

Методы, не изменяющие список и возвращающие значение:

count(x) - подсчитывает число вхождений значения x в список. Работает за время O(N)

index(x) - находит позицию первого вхождения значения x в список. Работает за время O(N)

index(x, from) - находит позицию первого вхождения значения x в список, начиная с позиции from. Работает за время O(N)

Методы, не возвращающие значение, но изменяющие список: 

append(x) - добавляет значение x в конец списка

extend(otherList) - добавляет все содержимое списка otherList в конец списка. В отличие от операции + изменяет объект к которому применен, а не создает новый

remove(x) - удаляет первое вхождение числа x в список. Работает за время O(N)

insert(index, x) - вставляет число x в список так, что оно оказывается на позиции index. Число, стоявшее на позиции index и все числа правее него сдвигаются на один вправо. Работает за время O(N)

reverse() - Разворачивает список (меняет значение по ссылке, а не создает новый список как myList[::-1]). Работает за время O(N)

Методы, возвращающие значение и изменяющие список:

pop() - возвращает последний элемент списка и удаляет его

pop(index) - возвращает элемент списка на позиции index и удаляет его. Работает за время O(N)


Обработка списков
Рассмотрим такую задачу: необходимо выбрать все нечетные элементы списка myList и удалить их из него. 

Попробуем решить задачу в лоб - просто будем перебирать все позиции в строке и, если на этой позиции стоит нечетное число, будем удалять его.

numbers = list(map(int, input().split()))
for i in range(len(numbers)):
    if numbers[i] % 2 != 0:
        numbers.pop(i)
print(' '.join(map(str, numbers)))

Такое решение будет работать неправильно в ситуации, когда в списке есть хоть одно нечетное число. Это связано с тем, что объект без названия с типом iterable и значением range(len(numbers)) сгенерируется один раз, когда интерпретатор впервые дойдет до этого места и уже никогда не изменится. Если в процессе мы выкинем из списка numbers хоть одно значение, то в процессе перебора всех индексов выйдем за пределы нашего списка. range, используемый в for, не будет менять свое значение если в процессе работы изменились параметры функции range.

Решение можно переписать с помощью while:

numbers = list(map(int, input().split()))
i = 0
while i < len(numbers):
    if numbers[i] % 2 != 0:
        numbers.pop(i)
    else:
        i += 1
print(' '.join(map(str, numbers)))

Такое решение будет работать, но оно не очень эффективно. Каждый раз при удалении элемента нам придется совершать количество операций, пропорциональное длине списка. Итоговое количество операций в худшем случае будет пропорционально квадрату количества элементов в списке.

В случае, если нет очень строгого ограничения в памяти, в задачах, где нужно удалить часть элементов списка гораздо проще создать новый список, в который нужно добавлять только подходящие элементы.

numbers = list(map(int, input().split()))
newList = []
for i in range(len(numbers)):
    if numbers[i] % 2 == 0:
        newList.append(numbers[i])
print(' '.join(map(str, newList)))

Сложность такого решения пропорциональна длине исходного списка, что намного лучше.


