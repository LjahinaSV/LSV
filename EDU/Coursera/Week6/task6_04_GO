Гражданская оборона
Штаб гражданской обороны Тридесятой области решил обновить план спасения
на случай ядерной атаки. Известно, что все n селений Тридесятой области
находятся вдоль одной прямой дороги. Вдоль дороги также расположены m бомбоубежищ,
 в которых жители селений могут укрыться на случай ядерной атаки.

Чтобы спасение в случае ядерной тревоги проходило как можно эффективнее,
необходимо для каждого селения определить ближайшее к нему бомбоубежище.

Формат ввода

В первой строке вводится число n - количество селений (1 <= n <= 100000).
Вторая строка содержит n различных целых чисел,
i-е из этих чисел задает расстояние от начала дороги до i-го селения.
В третьей строке входных данных задается число m - количество бомбоубежищ
(1 <= m <= 100000).
Четвертая строка содержит m различных целых чисел,
i-е из этих чисел задает расстояние от начала дороги до i-го бомбоубежища.
Все расстояния положительны и не превышают 10⁹.
Селение и убежище могут располагаться в одной точке.

Формат вывода

Выведите  n чисел - для каждого селения выведите номер ближайшего к нему бомбоубежища.
Бомбоубежища пронумерованы от 1 до m в том порядке,
в котором они заданы во входных данных.

Указание

Создайте список кортежей из пар (позиция селения, его номер в исходном списке),
а также аналогичный список для бомбоубежищ. Отсортируйте эти списки.

Перебирайте селения в порядке возрастания.

Для селения ближайшими могут быть два соседних бомбоубежища,
среди них надо выбрать ближайшее. При переходе к следующему селению
не обязательно искать ближайшее бомбоубежище с самого начала.
Его можно искать начиная с позиции, найденной для предыдущего города.
Аналогично, не нужно искать подходящее бомбоубежище до конца списка бомбоубежищ:
достаточно найти самое близкое. Если Вы неэффективно реализуете эту часть,
то решение тесты не пройдет.

Для хранения ответа используйте список,
где индекс будет номером селения, а по этому индексу будет запоминаться
номер бомбоубежища.

Примеры

Тест 1
Входные данные:
4
1 2 6 10
2
7 3

Вывод программы:
2 2 1 1

Тест 2
Входные данные:
1
1
1
2

Вывод программы:
1

Тест 3
Входные данные:
10
79 64 13 8 38 29 58 20 56 17
10
53 19 20 85 82 39 58 46 51 69

Вывод программы:
5 10 2 2 6 3 7 3 7 2

Вариант решения от слушателя Курсеры
# Функция определения индекса убежища, ближайшего к текущему селению
def mFind(i, j):
    d = abs(nList[i][0] - mList[j][0])
    while j < len(mList) - 1:
        if abs(nList[i][0] - mList[j + 1][0]) >= d:
            return j
        else:
            d = abs(nList[i][0] - mList[j + 1][0])
            j += 1
    return j


# Ввод исходных данных по селениям
n = int(input())
nData = list(map(int, input().split()[:n]))
# Ввод исходных данных по убежищам
m = int(input())
mData = list(map(int, input().split()[:m]))
# Формируем список Селения (расстояние, индекс селения в исходном списке)
nList = []
i = 0
while i < len(nData):
    nList.append((nData[i], i))
    i += 1
# Формируем список Убежища (расстояние, индекс убежища в исходном списке)
mList = []
i = 0
while i < len(mData):
    mList.append((mData[i], i))
    i += 1
# Сортируем списки Селения и Убежища по расстоянию на дороге:
# по первому элементу в подсписке
nList.sort()
mList.sort()
mNumList = []
i, j = 0, 0
while i < len(nList):
    # Формируем список ближайших убежищ (Индекс_селения, индекс убежища)
    # Поиск убежища начинаем с последнего найденного в списке убежищ
    j = mFind(i, j)
    mNumList.append((nList[i][1], mList[j][1]))
    i += 1
# Сортируем список (Индекс_ селения, индекс_убежища) по индексу селения
mNumList.sort()
i = 0
while i < len(mNumList):
    # Печатаем номера убежищ (индекс убежища + 1) в порядке индексов селений
    print(mNumList[i][1] + 1, end=' ')
    i += 1

Ещё идея
Б
Бородин Олег
Учащийся
4 года назад

Добрый день. Идея записывать дистанцию между поселениями и бомбоубежищами в кортежи, а потом эти кортежи переписывать, мне показалась мутерной. Это не оригинальное решение, скорее просто вариация на тему, но я сделал так:

Создаётся список с дистанцией до поселений (вводные данные): [9, 6, 3]

Создаётся список с дистанцией до бомбоубежищ (тоже вводные данные): [1, 8, 5]

Через цикл каждому элементу в списках добавляется порядковый номер (я добавлял через цикл, поэтому нумерация начинается с нуля).

поселения = [ [9, 0], [6, 1], [3, 2] ]

бомбы = [ [1, 0], [8, 1], [5, 2] ]

4. Оба списка сортируются по первым элементам (это которые дистанция, а не порядковые номера:

поселения = [ [3, 2], [6, 1], [9, 0] ]

бомбы = [ [1, 0], [5, 2], [8, 1] ]

5. Задача... эээ... решается. Когда удаётся найти минимальное расстояние от поселения до бомбы, к этому поселению добавляется третий элемент: порядковый номер бомбы + 1 (т.е. не 0, а 1, не 2, а 3 и т.д.):

 поселения = [ [3, 2, 1], [6, 1, 3], [9, 0, 2] ]

Полагаю, авторы задачи, рекомендуя создавать кортежи, хотели на этом этапе либо перезаписать кортежи, либо сделать что-то ещё, не знаю чего.

6. Теперь в списке 'поселения' содержатся следующие данные: дистанция, оригинальный порядковый номер поселения, номер бомбоубежища для ответа на задачу (с единицы, а не с нуля).

7.Список поселений сортируется по второму элементу, т.е. выстраивается в оригинальном порядке, как вводили числа:

 поселения = [ [9, 0, 2], [6, 1, 3], [3, 2, 1] ]

8. Остаётся вывести на печать третий элемент каждого поселения: 2, 3, 1

Фрагмент программы Патракова Елена
# Количество городов
n = int(input())
# Список номеров городов
n_city = [i for i in range(1, n + 1)]
# Заданный список расстояний
city = list(map(int, input().split()))
# Общий список вида расстояние-номер
list_city = [list(x) for x in zip(city, n_city)]
# Сортировка по расстоянию
list_city.sort(key=lambda x: x[0])

И ещё одно замечание Дымшаков
 имеет смысл создавать новый пустой список
 и в него класть номера поселений и номера бомбоубежищ, снова сортировать
 обычной сортировкой без ключа и потом оставлять только номера бомбоубежищ.

 Ещё одно решение Бабаев Усман Учащийся 8 месяцев назад

В основе решения лежит оптимальный алгоритм поиска для каждого n[i]
селения ближайшего m[j] бомбоубежища.
Все остальное ни что иное как приведение исходных данных к требуемому стандарту
для подачи в алгоритм.
Представленный алгоритм проверяет, во-первых, не является ли бомбоубежище
единственным или последним в списке.
Далее идет расчет диапазона значений, в рамках которого каждое n[i] селение
будет принадлежать m[j] бомбоубежищу.
То есть, для двух ближайших бомбоубежищ алгоритм рассчитывает середину
- между 3 и 7 середина 5, следовательно, все, что меньше или равно середине,
принадлежит бомбоубежищу 3 - остальное 7 и так далее проходит по списку.
И, конечно же, именованный параметр key в конце!

def sorter(point):
    return point[0]

c = int(input())
rc = list(map(int, input().split()))
b = int(input())
rb = list(map(int, input().split()))
for i in range(len(rc)):
    rc[i] = (rc[i], i + 1)
for i in range(len(rb)):
    rb[i] = (rb[i], i + 1)
rc.sort()
rb.sort()
g = 0
h = 0
v = []
while g < len(rc):
    if h == len(rb) - 1:
        v.append((rc[g][1], rb[h][1]))
    else:
        if rc[g][0] <= rb[h][0] + ((rb[h+1][0] - rb[h][0])//2):
            v.append((rc[g][1], rb[h][1]))
        elif rc[g][0] > rb[h][0] + ((rb[h+1][0] - rb[h][0])//2):
            h += 1
            continue
    g += 1
v.sort(key=sorter)
for i in range(len(v)):
    print(v[i][1], end=' ')