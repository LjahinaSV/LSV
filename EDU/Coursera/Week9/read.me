Объектно-ориентированное программирование
    https://ru.wikibooks.org/wiki/Python/Объектно-ориентированное_программирование_на_Python#Статический_метод
Комплексные числа
Инкапсуляция и конструкторы
Определение методов и стандартные функции
Создание классов
Обработка ошибок. Транспонирование
@ staticmethod
Наследование. Полиморфизм

Объектно-ориентированное программирование
Объектно-ориентированное программирование (ООП) является одной из парадигм программирования, созданной на базе императивного программирования для более удобного повторного использования кода и облегчения читаемости программ. 
ООП не является "серебряной пулей", которая решает все задачи наиболее удобным образом. Императивное программирование удобно для решения простых задач, использующих стандартные объекты. Повторное использование кода в императивной парадигме обеспечивается с помощью циклов и функций, написанных в императивном стиле.
Функциональное программирование удобно для задач, где существует ярко выраженный поток данных (data flow), который "перетекает" из одной функции в другую, изменяясь по пути. 
ООП же позволяет обеспечить повторное использование кода за счет того, что обрабатываемые программой объекты имеют много общего и лишь незначительные отличия в своем поведении.
ООП основано на трёх концепциях: инкапсуляция, наследование, полиморфизм.
Инкапсуляция - это помещение в "капсулу": логическое объединение данных и функций для работы с ними, а также сокрытие внутреннего устройства объекта с предоставлением интерфейса взаимодействия с ним (публичные методы).
Наследование - это получение нового типа объектов на основе уже существующего с частично или полностью заимствованный у родительского типа функциональностью. 
Полиморфизм - это предоставление одинаковых средств взаимодействия с объектами разной природы. Например, операция + может работать как с числами, так и со строками, несмотря на разную природу этих объектов.
Классом в Питоне называется описание структуры объекта (полей структуры) и методов (функций) для работы с данными в этой структуре.
Объектом называется экземпляр класса, где поля заполнены конкретными значениями. Объекты находятся в памяти программы и могут изменять своё состояние или выполнять какие-то действия с помощью вызова методов класса для этого объекта.

Инкапсуляция и конструкторы
Мы уже использовали ключевое слово class для создания структур - набора именованных полей, совокупность которых описывает объект. Однако, мы пользовались для их обработки отдельно лежащими функциями или кусками кода.
Было бы намного удобнее, если бы описание структуры объекта и методов работы с ним лежало рядом, для удобства изучения, модификации и использования. 
Мы будем рассматривать элементы ООП на примере комплексных (ударение на "е") чисел. Это забавный математический объект, который состоит из действительной (real) и мнимой (imaginary) части. Запись этого числа выглядит как re + im * i, где i - это квадратный корень из -1. Глубокое математическое понимание комплексных чисел нам не понадобится: достаточно понимать, что это структура с двумя полями re и im, где оба эти поля - вещественные числа.
Для создания новых объектов класса используется специальный метод, который называется "конструктор". Методы класса записываются внутри описания класса как функции, конструктор должен называться __init__. В качестве первого параметра они должны принимать переменную self - конкретный объект класса, с которым они работают.

Рассмотрим класс для комплексного числа, вызов конструктора и печать полей объекта:

class Complex:
    def __init__(self, re=0, im=0):
        self.re = re
        self.im = im
        
a = Complex(1, 2)
b = Complex(3)
c = Complex()
print(a.re, a.im)
print(b.re, b.im)
print(c.re, c.im)

Здесь конструктор содержит три параметра: self - пустой объект класса Complex, re и im по умолчанию равные нулю. Вызов конструктора осуществляется с помощью написания названия класса, в скобках указываются параметры конструктора (все, кроме self). Названия классов принято записывать с большой буквы, а объекты - с маленькой.
Вывод этой программы будет: 

1 2
3 0
0 0
Обратите внимание, что мы меняем переменные конкретного объекта класса, который передан в качестве параметра self. Если мы создали какие-то переменные в описании класса, то их значения были бы доступны во всех объектах этого класса и их можно было бы даже изменить, перечислив их имена в начале метода после выражения nonlocal. Такие переменные называются статическими, обычно они предназначены для хранения каких-то констант (что очень удобно если вы, например, описываете какой-то класс для физических вычислений). Их изменение может понадобится в экзотических ситуациях, например, при подсчете количества объектов класса. Мы не будем заострять на них внимание.

Определение методов и стандартные функции
Некоторые стандартные функции языка Питон являются всего лишь обертками над вызовом метода для передаваемого параметра. Например, функция str вызывает метод __str__ для своего параметра. Если мы опишем такой метод для нашего класса, то можно будет применять к нему функцию str явно и неявно (например, она автоматически вызовется при вызове print для объекта нашего класса). 

Мы бы хотели, чтобы __str__ возвращал текстовое представление нашего комплексного числа. Например, число с действительной частью 1 и мнимой 2 должно быть представлено в виде строки ''1+2i'', а число с действительной частью 3 и мнимой -4.5 - как ''3-4.5i''. Полное описание класса с добавленным методом будет выглядеть так:

class Complex:
    def __init__(self, re=0, im=0):
        self.re = re
        self.im = im
    def __str__(self):
        strRep = str(self.re)
        if self.im >= 0:
            strRep += '+'
        strRep += str(self.im) + 'i'
        return strRep
        
a = Complex(1, 2)
print(a)
b = Complex(3, -4.5)
print(b)

Переопределение операторов
В языке Питон можно переопределить и поведение операторов. Например, если у нас есть два числа x и y, то запись x + y реально преобразуется в вызов метода x.__add__(y). Значок операции + является всего лишь удобным для человека переопределением вызова метода add. 

Для комплексных чисел логично определена операция сложения: это сложение отдельно действительных и отдельно мнимых частей. В результате вызова метода для сложения двух чисел должен конструироваться новый объект класса Complex, а переданные в качестве параметров объекты не должны изменяться. Действительно, когда мы выполняем операция z = x + y для обычных чисел, то ожидаем, что сконструируется новый объект, к которому привяжется ссылка z, а x и y останутся без изменения.

Будем придерживаться этой же логики при реализации метода для сложения двух комплексных чисел. Наш метод __add__ должен принимать два параметра, каждый из которых является комплексным числом.

class Complex:
    def __init__(self, re=0, im=0):
        self.re = re
        self.im = im
    def __str__(self):
        strRep = str(self.re)
        if self.im >= 0:
            strRep += '+'
        strRep += str(self.im) + 'i'
        return strRep
    def __add__(self, other):
        newRe = self.re + other.re
        newIm = self.im + other.im
        return Complex(newRe, newIm)
        
a = Complex(1, 2)
b = Complex(3, -4.5)
print(a + b)

Переопределять метод add имеет смысл только в тех ситуациях, когда программисту, использующему ваш класс, будет очевиден смысл операции +. Например, если бы вы создали класс для описание некоторых характеристик человека, то операция + для двух объектов-людей воспринималась разными пользователями вашего класса совершенно по-разному, в зависимости от развитости фантазии читателя. Такого неоднозначного понимания лучше избегать и вовсе не переопределять операцию +, если результат её работы не очевиден.

Проверка класса объекта
Переопределим для комплексных чисел ещё одну операцию - умножение. При этом мы хотим уметь умножать комплексные числа как на целые или действительные, так и на другие комплексные числа. 

При умножении комплексного числа вида a+b * i$на целое или вещественное число x результатом будет комплексное число a * x + b * x * b.
Переменожение двух комплексных чисел производится аналогично умножению двух многочленов первой степени:
(a + b * i) * (c + d * i) = a * c + (a * d + b * c) * i + b * d * i**2
Мы знаем, что i**2 = -1. Значит окончательно результат умножения будет выглядеть так: 
a * c - b * d + (a * d + b * c) * i
Нам осталось понять, как определить, передано ли в наш метод комплексное или не комплексное число. 

В языке Питон существует функция isinstance, которая в качестве первого параметра принимает объект, а в качестве второго - название класса. Она возвращает истину, если объект относится к данному классу и ложь в противном случае. Эта функция позволит нам добиться нужной функциональности от метода __mul__, умножающего числа.

class Complex:
    def __init__(self, re=0, im=0):
        self.re = re
        self.im = im
    def __str__(self):
        strRep = str(self.re)
        if self.im >= 0:
            strRep += '+'
        strRep += str(self.im) + 'i'
        return strRep
    def __add__(self, other):
        newRe = self.re + other.re
        newIm = self.im + other.im
        return Complex(newRe, newIm)
    def __mul__(self, other):
        if isinstance(other, Complex):
            newRe = self.re * other.re - self.im * other.im
            newIm = self.re * other.im + self.im * other.re
        elif isinstance(other, int) or isinstance(other, float):
            newRe = self.re * other
            newIm = self.im * other
        return Complex(newRe, newIm)
    __rmul__ = __mul__
        
a = Complex(1, 2)
b = Complex(3, -4.5)
print(a * b)
print(a * 2)

Кроме добавленного метода __mul__ внимания также заслуживает строка __rmul__ = __mul__. Это присваивание одного метода (функции) другому, т.е. при вызове метода __rmul__ будет вызываться тот же самый метод __mul__. 

В языке питон операция a * b  заменяется на вызов метода a.__mul__(b). Если a было комплексным числом, а b - вещественным, то вызовется метод __mul__ для объекта a нашего класса Complex.

Однако, если a было вещественным числом, а b - комлексным, то произойдет попытка вызвать метод __mul__ для объекта класса float. Естественно, разработчики стандартной библиотеки языка Питон не могли предположить, что вы когда-нибудь напишите класс Complex и будете пытаться умножить на него вещественное число, поэтому метод __mul__, где в качестве параметра передается нечто неизвестное, будет заканчивать свою работу с ошибкой. Чтобы избежать таких ситуаций в языке Питон после неудачной попытки совершить a.__mul__(b) просходит попытка совершить действие b.__rmul__(a) и в нашем случае она заканчивается успехом.

Обработка ошибок
Время от времени в программах возникают ошибочные ситуации, которые не могут быть обработаны в том месте, где возникла ошибка, а должны быть обработаны тем или иным образом в более внешней части программы. 

Например, если на этапе выполнения промежуточной логики обнаружилось, что вы пытаетесь записать строку в то, что должно быть числом, то вы ничего не можете с этим сделать. В таком случае нужно вываливаться из стека вызовов функций или методов промежуточной логики до тех пор, пока мы не дойдем до фронтенда, который сообщит пользователю о том, что он ввел недопустимое значение и попросит, например, ввести его заново.

Наверняка вы сталкивались с ситуацией заполнения огромной формы, попытка отправить которую приводила к тому, что появлялось окошко со словом "ошибка" без каких-либо уточнений. Это плохой стиль, сообщение об ошибке должно быть информативным, чтобы позволить быстро её найти и исправить. Таким образом, при создании ошибки нужно передавать исчерпывающую информацию о ней.

В нашем примере с вещественными числами мы можем рассмотреть такой пример ошибки: умножение комплексного числа на что-то, отличное от целого, вещественного или комплексного числа. Когда мы дошли до этапа умножения - мы уже ничего не можем предпринять для исправления этой ошибки, кроме как просигнализировать о ней в то место, откуда была вызвана наша операция умножения.

При этом на этапе вызова операции умножения мы уже можем предпринять какие-то действия. Например, сообщить пользователю о том, какую фигню он ввел и попросить ввести все-таки комплексное число. Или, если мы обрабатываем последовательность, из которой нужно вычленить и перемножить комплексные числа - просто перейти к следующему элементу последовательности. На этапе когда мы дошли до неудачного выполнения операция умножения мы не знаем и не можем знать как должна себя вести конкретная программа при возникновении такой ошибки.

Когда мы дойдем до ошибочной операции мы можем сконструировать специальный класс, содержащий подробное описание ошибки и выбросить его в то место, которое способно его обработать.

Выбрасывается ошибка с помощью команды raise, а ловится блоком try-except. Для случая умножения комплексного числа на мусор мы можем сконструировать класс ошибки, содержащий в себе ссылку как на комплексное число, так и на второй аргумент метода умножения.

Класс для ошибки должен быть наследником стандартного класса BaseException. Пока для нас это значит только то, что при создании описания класса ошибки мы должны написать в скобках после его названия BaseException. Потенциально ошибочные действия должны выполняться в блоке try, а команды для обработки ошибки должны быть в блоке except. Пример с обработкой ошибки будет выглядеть так:

class ComplexError(BaseException):
    def __init__(self, Complex, other):
        self.arg1 = Complex
        self.arg2 = other

class Complex:
    def __init__(self, re=0, im=0):
        self.re = re
        self.im = im
    def __str__(self):
        strRep = str(self.re)
        if self.im >= 0:
            strRep += '+'
        strRep += str(self.im) + 'i'
        return strRep
    def __add__(self, other):
        newRe = self.re + other.re
        newIm = self.im + other.im
        return Complex(newRe, newIm)
    def __mul__(self, other):
        if isinstance(other, Complex):
            newRe = self.re * other.re - self.im * other.im
            newIm = self.re * other.im + self.im * other.re
        elif isinstance(other, int) or isinstance(other, float):
            newRe = self.re * other
            newIm = self.im * other
        else:
            raise ComplexError(self, other)
        return Complex(newRe, newIm)
    __rmul__ = __mul__

a = Complex(1, 2)        
try:
    res = a * 'abcd'
except ComplexError as ce:
    print('Error in mul with args:', ce.arg1, ce.arg2)

Вывод этой программы будет:

Error in mul with args: 1+2i abcd

По нему легко понять, что ошибка возникает при операции умножения и увидеть, что было передано в неё в качестве аргументов.

После команды except мы можем указать имя класса ошибки, который он должен обрабатывать, затем написать ''as'' и указать имя переменной, в которую попадет объект с описанием конкретной ошибки.

Блоков except может быть несколько для обработки ошибок разных типов. Проверки выполняются последовательно, будет выполнен тот блок команд, у которого имя класса совпадает с именем класса ошибки или является его предком в дереве иерархии наследования.


Наследование и полиморфизм
Операции сложения и умножения на вещественное или целое число для комплексных чисел очень похожи на поведение свободных векторов на плоскости. Они соответствуют сложению векторов или умножение вектора на число, где действительная часть комплексного числа является x-координатой вектора, а мнимая - y-координатой. 

Кроме того, свободный вектор обладает некоторыми операциями, которые характерны только для него, но не для вещественного числа. Например, это может быть метод length, вычисляющий длину вектора. Нам не хотелось бы засорять код для описания комплексного числа методами для работы со свободным вектором, но с другой стороны не хотелось бы заново переписывать методы сложения и умножения для свободных векторов.

В такой ситуации разумно создать новый класс для описания свободного вектора (или точки на плоскости, что то же самое), который унаследовал бы все методы комплексных чисел и добавил бы новый метод length.

Мы уже знаем, что для того, чтобы пронаследовать класс от другого достаточно в описании класса указать в круглых скобках, от кого он наследуется. Таким образом, мы можем записать наше описание класса Point с определенным методом length так:


class ComplexError(BaseException):
    def __init__(self, Complex, other):
        self.arg1 = Complex
        self.arg2 = other

class Complex:
    def __init__(self, re=0, im=0):
        self.re = re
        self.im = im
    def __str__(self):
        strRep = str(self.re)
        if self.im >= 0:
            strRep += '+'
        strRep += str(self.im) + 'i'
        return strRep
    def __add__(self, other):
        newRe = self.re + other.re
        newIm = self.im + other.im
        return Complex(newRe, newIm)
    def __mul__(self, other):
        if isinstance(other, Complex):
            newRe = self.re * other.re - self.im * other.im
            newIm = self.re * other.im + self.re * other.im
        elif isinstance(other, int) or isinstance(other, float):
            newRe = self.re * other
            newIm = self.im * other
        else:
            raise ComplexError(self, other)
        return Complex(newRe, newIm)
    __rmul__ = __mul__

class Point(Complex):
    def length(self):
        return (self.re**2 + self.im**2)**(1/2)

a = Point(3, 4)
b = Complex(1, 2)
print(a.length())
c = a + b
print(c)

Вывод этой программы будет 

5.0
4+6i

Здесь мы не только убедились в том, что свежесозданный метод работает, но и сделали довольно странную вещь: сложили точку на плоскости с комплексным числом. Дело в том, что объекта класса Point также одновременно является и объектом типа Complex, т.к. Point пронаследован от Complex. Point лишь расширяет и дополняет Complex, а значит Point может смело быть интерпретирован как Complex, но не наоброт.

В этом примере будут истинны выражения isinstance(a, Point) и isinstance(a, Complex), но будет ложно выражение isinstance(b, Point).

Переопределение методов
Если мы попытаемся напечатать объект типа Point, то он напечатается как комплексное число. Нам хотелось бы, чтобы точки на плоскости печатались в виде (x, y), а не x+yi.

В языке Питон любой метод можно переопределить в наследнике, что мы и сделаем для метода __str__ для класса Point:


class ComplexError(BaseException):
    def __init__(self, Complex, other):
        self.arg1 = Complex
        self.arg2 = other

class Complex:
    def __init__(self, re=0, im=0):
        self.re = re
        self.im = im
    def __str__(self):
        strRep = str(self.re)
        if self.im >= 0:
            strRep += '+'
        strRep += str(self.im) + 'i'
        return strRep
    def __add__(self, other):
        newRe = self.re + other.re
        newIm = self.im + other.im
        return Complex(newRe, newIm)
    def __mul__(self, other):
        if isinstance(other, Complex):
            newRe = self.re * other.re - self.im * other.im
            newIm = self.re * other.im + self.re * other.im
        elif isinstance(other, int) or isinstance(other, float):
            newRe = self.re * other
            newIm = self.im * other
        else:
            raise ComplexError(self, other)
        return Complex(newRe, newIm)
    __rmul__ = __mul__

class Point(Complex):
    def length(self):
        return (self.re**2 + self.im**2)**(1/2)
    def __str__(self):
        return str((self.re, self.im))

a = Point(3, 4)
print(a)

Наш метод обязан возвращать строку, но мы можем воспользоваться функцией str от кортежа, которая выдаст нам нужный результат. 

Проектирование структуры классов
Структура описания классов представляет собой дерево (на самом деле в Питоне - ациклический граф), пронаследованный от единого корня - базового пустого класса.

С помощью грамотно спроектированной структуры классов можно добиться легкой читаемости и максимального повторного использования кода, обеспечения единого интерфейса и множество других радостей.

Однако, внесение фичи или изменение на высоком уровне иерархии классов может привести к необходимости выполнить огромное количество работы по модификации всех потомков этого класса, а также к полной несовместимости с предыдущей версией. Многочисленные изменения такого рода приводят к уродливым конструкциям, которые невозможно понимать и отлаживать.

В то же время, закладывание перспективных фичей в структуру классов ведет к переусложнению и сводит на нет все повторное использование кода за счет громоздкости конструкций. Кроме того, перспективные фичи могут быть недостаточно обдуманы и приведут к еще большему уродству, когда дело дойдет до их реальной реализации (если дойдет).

Таким образом, грамотное проектирование системы классов требует не только хорошего знания паттернов проектирования, но и большого практического опыта. На начальном этапе стоит обучаться проектированию систем, в которые не планируется внесение изменений.
