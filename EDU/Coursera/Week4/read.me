Functions and recursion
Функции и рекурсия. Задачи


Функции
Функции - части программы, которые можно повторно вызывать с разными параметрами, чтобы не писать много раз одно и то же. Функции в программировании немного отличаются от математических функций. В математике функции могут только получить параметры и дать ответ, в программировании же функции умеют делать что-нибудь полезное, например, ничего не возвращать, но что-то печатать. 

Функции чрезвычайно полезны, если одни и те же действия нужно выполнять несколько раз. Но некоторые логические блоки работы с программой иногда тоже удобно оформлять в виде функции. Это связано с тем, что человек может одновременно держать в голове ограниченное количество вещей. Когда программа разрастается, отследить все уже очень сложно. В пределах одной небольшой функции запутаться гораздо сложнее - известно, что она получает на вход, что должна выдать, а об остальной программе в это время можно не думать.

В программировании также считается хорошим стилем писать функции, умещающиеся на один экран. Тогда можно одновременно окинуть взглядом всю функцию и не нужно крутить текст туда-сюда. Поэтому, если получилось что-то очень длинное, то нужно нарезать его на кусочки так, чтобы каждый из них был логичным (делал какое-то определенное действие, которое можно назвать) и не превышал при этом 10-15 строк.

Мы уже использовали готовые функции, такие как print, len и некоторые другие. Эти функции описаны в стандартной библиотеке или других подключаемых библиотеках. Сегодня мы научимся создавать свои функции.


Использование функций
Рассмотрим, как создать свою функцию, на примере вычисления факториала. Текст программы без функции выглядит так: 

n = int(input())
fact = 1
i = 2
while i <= n:
    fact *= i
    i += 1
print(fact)

Вычисление факториала можно вынести в функцию, тогда эта же программа будет выглядеть так:

def factorial(num):
    fact = 1
    i = 2
    while i <= num:
        fact *= i
        i += 1
    return fact

n = int(input())
print(factorial(n))

Описание функции должно идти в начале программы. На самом деле, оно может быть в любом месте, до первого вызова функции factorial.

Определение функции должно начинаться со слова def (сокращение от define, определить). Дальше идет имя функции, после которого в скобках через запятую перечисляются параметры (у нашей функции всего один параметр). После закрытия скобки должно стоять двоеточие.

Команды, выполняемые в функции должны записываться с отступом, как в блоках команд if или while.

В нашей функции num - это параметр, на его место подставляется то значение, с которым функция была вызвана. Действия внутри функции точно такие же, как в обычной программе, кроме дополнительной команды return. Команда return возвращает значение функции (оно должно быть записано через пробел после слова return) и прекращает её работу. Возвращенное значение подставляется на то место, где осуществлялся вызов функции.

Команда return может встречаться в любом месте функции. После того как она выполнится, работа функции будет прекращена. Здесь есть некоторая аналогия с командой break, применяемой для выхода из цикла.

Вызовы функций из функции
Функцию подсчета факториала можно использовать для подсчета биномиальных коэффициентов (числа сочетаний). Формула для подсчета числа сочетаний выглядит так: n! / (k! * (n - k)!).

Если бы мы не пользовались функциями, то нам потребовалось бы три раза записать почти одно и то же. С помощью функций вычисление выглядит намного проще:

print(factorial(n) // (factorial(k) * factorial(n - k)))

Подсчет биномиальных коэффициентов можно также оформить в виде функции с двумя параметрами:

def binomial(n, k):
    return factorial(n) // (factorial(k) * factorial(n - k))
    
    
Возврат значений
Как было сказано выше, выполнение функции прерывается по команде return. Для примера рассмотрим функцию поиска максимума из двух чисел, которые передаются ей в качестве параметров: 

def max2(a, b):
    if a > b:
        return a
    else:
        return b

Её можно было бы записать и по-другому:

def max2(a, b):
    if a > b:
        return a
    return b

Если условие в if'е было истинным, то выполнится команда return a и выполнение функции будет прекращено - до команды return b выполнение просто не дойдет.

С помощью функции max2 можно реализовать функцию max3, возвращающую максимум из трех чисел:

def max3(a, b, c):
    return max2(max2(a, b), c)    

Эта функция дважды вызывает max2: сначала для выбора максимума среди чисел a и b, а затем для выбора максимума между найденным значением и оставшимся числом c.

Здесь нужно обратить внимание, что в качестве аргумента функции может передаваться не только переменная или константное значение, но и результат вычисления любого арифметического выражения. Например, результат, возвращенной другой функцией.

Наши функции max2 и max3 будут работать не только для чисел, но и для любых сравнимых объектов, например, для строк.

Возврат нескольких значений функцией
Рассмотрим случай, когда функция должна вернуть несколько значений на примере функции, упорядочивающей два числа. Чтобы вернуть несколько значений, достаточно записать их в return через запятую. Аналогично, через запятую должны быть перечислены переменные, в которые будут попадать вычисленные значения. 

def sort2(a, b):
    if a < b:
        return a, b
    else:
        return b, a
a = int(input())
b = int(input())
minimum, maximum = sort2(a, b)
print(minimum, maximum)

На самом деле, при перечислении значений через запятую, формируются объекты типа "кортеж", их подробное изучение будет на следующей лекции. Имеющихся знаний достаточно для использования функций, возвращающих несколько значений.

Возврат логических значений
Иногда удобно оформлять даже простые вещи в виде функций, чтобы повысить читаемость программы. Например, если нужно проверить число на четность, то гораздо понятнее будет каждый раз вызывать функцию isEven(n), а не писать каждый раз n % 2 == 0. 

Такая функция может выглядеть так:

def isEven(n):
    return n % 2 == 0

Результатом работы этой функции будет истина или ложь. Теперь функцию очень удобно применять в if'ах:

if isEven(n):
    print("EVEN")
else:
    print("ODD")

Если есть сложное логическое выражение, то лучше оформить его в виде функции с говорящим названием - так программу будет легче читать, а вероятность ошибок в ней резко снизится.    


Локальные и глобальные переменные
Все переменные, которыми мы пользовались до сегодняшнего дня, были глобальными. Глобальные переменные видны во всех функциях программы. 

Например, такой код:

def f():
    print a
a = 1
f()
напечатает 1 и выполнится без ошибок. Переменная a - глобальная, поэтому мы можем смотреть на её значение из любой функции. На момент вызова функции f переменная a уже создана, хотя описание функции и идет раньше присваивания.

Если же инициализировать переменную внутри функции, то использовать её вне функции невозможно. Например, такой код:

def f():
    a = 1
f()
print(a)
завершится с ошибкой "builtins.NameError: name 'a' is not defined" (переменная a не определена). Переменные, значения которых изменяются внутри функции по умолчанию считаются локальными, т.е. доступными только внутри функции. Как только функция заканчивает свою работу, то переменная уничтожается.

Таким образом, если в функции происходило присваивание какой-то переменной, то эта переменная считается локальной. Если присваиваний не происходило, то переменная считается глобальной.

Локальные переменные можно называть такими же именами, как и глобальные. Например, вывод такого кода:

def f():
    a = 1
    print(a, end=' ')
a = 0
f()
print(a)
Будет "1 0". Сначала произойдет вызов функции f, в которой будет создана локальная переменная a со значением 1 (получить доступ к глобальной переменной a из функции теперь нельзя), затем функция закончит свою работу и будет выведена глобальная переменная a, со значением которой ничего не случилось.

Переменная считается локальной даже в случае, если её присваивание происходило внутри условного оператора (даже если он никогда не выполнится):

def f():
    print(a)
    if False:
        a = 0
a = 1
f()
Эта программа завершится с ошибкой builtins.UnboundLocalError: local variable 'a' referenced before assignment (обращение к переменной до инициализации). Любое присваивание значения переменной внутри тела функции делает переменную локальной.

С помощью специальной команды global можно сделать так, что функция сможет изменить значение глобальной переменной. Для этого нужно записать в начале функции слово global, а затем через запятую перечислить имена глобальных переменных, которые функция сможет менять. Например, такой код:

def f():
    global a
    a = 1
    print(a, end=' ')
a = 0
f()
print(a)
выведет "1 1", т.к. значение глобальной переменной будет изменено внутри функции.

Все параметры функции являются локальными переменными со значениями, которые были переданы в функцию. Параметры также можно изменять и это никак не повлияет на значения переменных в том месте, откуда была вызвана функция (если тип объектов-параметров был неизменяемым).

Использование глобальных переменных как на чтение, так и на запись внутри функций - очень плохой тон. Это связано с тем, что другие люди могут захотеть использовать некоторые отдельные функции из вашего кода, которые не будут работать вне вашей программы в случае использования глобальных переменных.

Поэтому использование глобальных переменных внутри функций в нашем курсе строго запрещено. Все нужное для работы функции должно передаваться в качестве параметров.


Рекурсия
Мы уже пробовали запускать функцию из другой функции и все работало. Ничто не мешает запустить из функции саму себя – тогда просто создастся новый экземпляр функции, который будет выполнять те же команды. Такой процесс называется рекурсией. 

Представим себе, что у нас есть миллиард человек (это будущие экземпляры функции), сидящих в ряд, и у каждого из них есть листочек для записи (это его локальная память). Нам нужно произносить числа и написать инструкцию для людей так, чтобы они в итоге сказали все числа из последовательности в обратном порядке. Пусть каждый из них будет записывать на своем листочке только одно число. Тогда инструкция для человека будет выглядеть так:

1) Запиши названное число

2) Если число не последнее – потереби следующего за тобой человека, пришла его очередь работать

3) Когда следующий за тобой человек сказал, что он закончил – назови записанное число

4) Скажи тому, кто тебя теребил (предыдущий человек), что ты закончил 

Формализуем задачу. Пусть задается последовательность натуральных чисел, заканчивающаяся нулем. Необходимо развернуть ее с помощью рекурсии.

def rec():
    n = int(input())
    if n != 0:
        rec()
        print(n)
rec()
Эта функция осуществляет действие (вывод числа) на рекурсивном спуске, т. е. после рекурсивного вызова.


Использование рекурсии
Рассмотрим задачу, где действия выполняются как на рекурсивном подъёме, так и на рекурсивном спуске. Пусть дана последовательность, которая оканчивается нулём. Необходимо вывести все чётные члены последовательности в прямом порядке, а затем все нечётные члены последовательности в обратном порядке. Её решение будет выглядеть так: 

def rec():
    n = int(input())
    if n != 0:
        if n % 2 == 0:
            print(n)
        rec()
        if n % 2 != 0:
            print(n)
rec()
Каждый экземпляр функции считывает в свою локальную переменную n число, если оно чётное, то сразу выводит его и запускает следующий экземпляр. После того, как все последующие экземпляры функции окончили работу (и вывели последующие нечётные числа в обратном порядке), функция выводит число, если оно было нечетным.

Рассмотрим еще один пример: подсчитать факториал числа, не пользуясь циклами:

def factorial(n):
    if n == 0:
        return 1
    return n * factorial(n - 1)
n = int(input())
print(factorial(n))
Тем, кто знаком с методом математической индукции, будет довольно просто осознать рекурсию. Как и в математической индукции, в рекурсии должна быть база (момент, когда функция не вызывает другую рекурсивную функцию) и переход (правило, по которому считается результат по известному результату для меньшего параметра). Наша функция подсчета факториала делает только свою работу, но пользуется результатами чужого труда. Например, если функция получила на вход параметр 4, то должна вернуть 4 умноженное на 3! (который будет посчитан другими функциями). В случае факториала аналогом "базы индукции" может выступать 0! - по определению он равен единице.

Эти примеры иллюстрируют общую схему написания рекурсивных функций: сначала проверяется условие, когда функция должна закончиться, а дальше делается все остальное. При этом параметр должен сходиться к значению базы. Обычно это означает, что при каждом следующем вызове рекурсии параметр должен уменьшаться.


